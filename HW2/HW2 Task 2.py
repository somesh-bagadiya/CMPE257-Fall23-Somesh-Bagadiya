# -*- coding: utf-8 -*-
"""HW2_3.1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UHazQ3pfBiwid8b2BYQkMPsCOq1Z3-2x
"""

#### CREDITS: Wencen Wu ####
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#parameters
rad = 10
thk = 5
sep = 5

#n data points,(x1,y1) are the coordinates of the top semi-circle
def generatedata(rad,thk,sep,n,x1 = 0,y1 = 0):
    # center of the top semi-circle
    X1 = x1
    Y1 = y1

    # center of the bottom semi-circle
    X2 = X1 + rad + thk / 2
    Y2 = Y1 - sep

    # data points in the top semi-circle
    top = []
    # data points in the bottom semi-circle
    bottom = []

    # parameters
    r1 = rad + thk
    r2 = rad

    cnt = 1
    while(cnt <= n):
        #uniformed generated points
        x = np.random.uniform(-r1,r1)
        y = np.random.uniform(-r1,r1)

        d = x**2 + y**2
        if(d >= r2**2 and d <= r1**2):
            if (y > 0):
                top.append([X1 + x,Y1 + y])
                cnt += 1
            else:
                bottom.append([X2 + x,Y2 + y])
                cnt += 1
        else:
            continue

    return top,bottom


def check_missing_points(w):
    X = data[['x0', 'x1', 'x2']].values
    hypo_y = np.sign(np.dot(X, w))
    mismatched_indices = np.where(hypo_y != data["y"].values)[0]
    return mismatched_indices.tolist()

def pocket_algo(w):
    global max_itr
    w_best = tuple(w)
    miss_points = tuple(check_missing_points(w_best))
    w_best_points = len(miss_points)
    l_data = len(data)
    Ein = []
    n = max_itr # maxnumber of iterations
    for i in range(n):
        j = miss_points[0]
        w[0] = w[0] + data["y"][j]*data["x0"][j]
        w[1] = w[1] + data["y"][j]*data["x1"][j]
        w[2] = w[2] + data["y"][j]*data["x2"][j]
        
        miss_points = tuple(check_missing_points(w))
        w_points = len(miss_points)
        Ein.append(w_best_points/l_data)
        
        if(w_points < w_best_points):
            w_best = tuple(w)
            w_best_points = w_points
        
        if(w_points == 0):
            w_best = tuple(w)
            w_best_points = w_points
            break

    plot_graph(w_best, "Pocket Algorithm")
    plot_Ein(Ein)
    print("Final Weights (Pocket):",w_best, "Number of Missclassified points:", w_best_points)

def linearRegression(X,Y):
    XT = np.transpose(X)
    XtX = np.matmul(XT,X)
    X_inv = np.linalg.inv(XtX)
    X_pi = np.matmul(X_inv,XT)
    W = np.matmul(X_pi,Y)
    
    miss_points = check_missing_points(W)
    
    print("Final Weights (Linear Regression):", W, "Number of Missclassified Points:", len(miss_points))
    return W

def linearRegression_3d(X_poly, Y):
    X_poly_t = np.transpose(X_poly)
    W = np.linalg.inv(X_poly_t.dot(X_poly)).dot(X_poly_t).dot(Y)
    # print("Coefficiets:", coefficients)
    miss_points = check_missing_points_3d(W)
    
    print("Final Weights (Linear Regression 3d):", W, "Number of Missclassified Points:", len(miss_points))
    
    return W

def check_miss_points(w):
    
    X = data[['x0', 'x1', 'x2']].values
    hypo_y = np.sign(np.dot(X, w))
    mismatched_indices = np.where(hypo_y != data["y"].values)[0]
    miss_list = mismatched_indices.tolist()
    len_miss_list = len(miss_list)
    if(len_miss_list>0):
        return True, miss_list[0]
    else:
        return False, -10

def perceptron_algo(w):
    flag, p_miss = check_miss_points(w)
    i = 0
    while flag:
        w[0] = w[0] + data["y"][p_miss]*data["x0"][p_miss]
        w[1] = w[1] + data["y"][p_miss]*data["x1"][p_miss]
        w[2] = w[2] + data["y"][p_miss]*data["x2"][p_miss]
        flag, p_miss = check_miss_points(w)
        i+=1
        if(i>1000):
            print("Perceptron Algorithm: The data is not linearly seperable or has some noisy data.")
            return None
    plot_graph(w, "Perceptron")
    miss_points = check_missing_points(w)
    print("Final Weights (Perceptron):", w, "iterations:", i, "Number of Missclassified Points:", len(miss_points))

def plot_Ein(Ein):
    plt.xlabel("Iterations")
    plt.ylabel("Ein (In-Sample Error)")
    plt.title("Ein vs. Iterations for Pocket Algorithm")
    plt.plot(Ein)
    plt.show()

def plot_graph(w, tit):
    axes = plt.gca()
    color = np.where(data["y"]==1, "red", "blue")
    plt.scatter(list(data['x1']), list(data['x2']), c=color)

    x_vals = np.array(axes.get_xlim())
    y_vals = []
    for i in x_vals:
        y = -w[0]/w[2] - (w[1]/w[2] * i)
        y_vals.append(y)
    plt.plot(x_vals, y_vals, '--')
    plt.title(tit)
    plt.show()
    
def check_missing_points_3d(w):
    X = data_3d.values
    hypo_y = np.sign(np.dot(X[:,:-1], w))
    mismatched_indices = np.where(hypo_y != data_3d["y"].values)[0]
    return mismatched_indices.tolist()

def pocket_algo_3d(w):
    global max_itr
    w_best = tuple(w)
    miss_points = tuple(check_missing_points_3d(w_best))
    w_best_points = len(miss_points)
    l_data = len(data_3d)
    Ein = []
    n = max_itr # maxnumber of iterations
    for i in range(n):
        j = miss_points[0]
        
        x = data_3d.iloc[j,:-1]
        y = data_3d.iloc[j,-1]
        w = w + x*y
        
        miss_points = tuple(check_missing_points_3d(w))
        w_points = len(miss_points)
        Ein.append(w_best_points/l_data)
        
        if(w_points < w_best_points):
            w_best = tuple(w)
            w_best_points = w_points
        
        if(w_points == 0):
            w_best = tuple(w)
            w_best_points = w_points
            break

    # plot_graph(w_best, "Pocket Algorithm 3d")
    plot_Ein(Ein)
    print("Final Weights (Pocket 3d):",w_best, "Number of Missclassified points:", w_best_points)
    return w

def plot10poly(w, tit, color='red'):
    color_1 = np.where(data_3d["y"]==1, "red", "blue")
    plt.scatter(list(data_3d[1]), list(data_3d[2]), c=color_1)
    axes = plt.gca()
    xlims = axes.get_xlim()
    ylims = axes.get_ylim()
    x1 = np.linspace(xlims[0], xlims[1], 1000)
    x2 = np.linspace(ylims[0], ylims[1], 1000)
    # meshgrid
    XM1, XM2 = np.meshgrid(x1, x2)

    w0 = w[0]
    w1 = w[1]
    w2 = w[2]
    w3 = w[3]
    w4 = w[4]
    w5 = w[5]
    w6 = w[6]
    w7 = w[7]
    w8 = w[8]
    w9 = w[9]
    
    z = w0 + w1*XM1 + w2*XM2 + w3*XM1**2 + w4*XM2**2 + w5*XM1*XM2 + w6*XM1**3 + w7*XM2**3 + w8*XM1**2*XM2 + w9*XM1*XM2**2
    # for i in range(data_3d.shape[1]-1):
    #     z = z + w[i]*data_3d[i]
    plt.contour(XM1, XM2, z, 1, colors = color)
    plt.title(tit)
    plt.show()

rad = 10
thk = 5
sep = 5

top,bottom = generatedata(rad,thk,sep,1000)

X1 = [i[0] for i in top]
Y1 = [i[1] for i in top]

X2 = [i[0] for i in bottom]
Y2 = [i[1] for i in bottom]

x0 = [1]*(len(top)+len(bottom))
x1 = X1 + X2
x2 = Y1 + Y2
y = [1]*len(top) + [-1]*len(bottom)

plt.scatter(X1,Y1,s = 1)
plt.scatter(X2,Y2,s = 1)
plt.show()

data = pd.DataFrame({"x0":x0, "x1":x1, "x2":x2, "y":y})

w = [0,0,0]
perceptron_algo(w)

X = data.iloc[:, :3].values
Y = data.iloc[:, -1].values
W = linearRegression(X,Y)
plot_graph(W, "Linear Regression")
print("Final Weights (Linear Regression):", W)

perceptron_algo(W)

rad = 10
thk = 5
sep = -5

top,bottom = generatedata(rad,thk,sep,2000)

X1 = [i[0] for i in top]
Y1 = [i[1] for i in top]

X2 = [i[0] for i in bottom]
Y2 = [i[1] for i in bottom]

x0 = [1]*(len(top)+len(bottom))
x1 = X1 + X2
x2 = Y1 + Y2
y = [1]*len(top) + [-1]*len(bottom)

plt.scatter(X1,Y1,s = 1)
plt.scatter(X2,Y2,s = 1)
plt.show()

data = pd.DataFrame({"x0":x0, "x1":x1, "x2":x2, "y":y}) 

w = [0,0,0]
perceptron_algo(w)
# The data is not linearly seperable, therefore the perceptron will never end as there will be always a point which is missclassified

max_itr = 100000
w = [0,0,0]
pocket_algo(w)

X = data.iloc[:, :3].values
Y = data.iloc[:, -1].values
W = linearRegression(X,Y)
plot_graph(W, "Linear Regression")

data_x = np.array(top + bottom)
data_poly = np.c_[[1]*len(data_x), data_x, data_x[:, 0]**2, data_x[:, 1]**2, data_x[:, 0] * data_x[:, 1], data_x[:, 0]**3, data_x[:, 1]**3, data_x[:, 0]**2*data_x[:, 1], data_x[:, 1]**2*data_x[:, 0]]
data_3d = pd.DataFrame(data_poly)
data_3d.insert(data_3d.shape[1],'y',y)

max_itr = 100000
w = [0]*10
w_pocket_3d = pocket_algo_3d(w)
plot10poly(w_pocket_3d, "Pocket Algorithm 3d")

X = data_3d.iloc[:, :-1].values
Y = data_3d.iloc[:, -1].values
W = linearRegression_3d(X,Y)
plot10poly(W, "Linear Regression 3d")